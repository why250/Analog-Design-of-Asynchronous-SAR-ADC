# NonIdealSARADC ç±»æ€ç»´å¯¼å›¾

## ğŸ“‹ ç›®å½•
1. [ç±»ç»§æ‰¿å…³ç³»](#ç±»ç»§æ‰¿å…³ç³»)
2. [åˆå§‹åŒ–æµç¨‹](#åˆå§‹åŒ–æµç¨‹)
3. [æ–¹æ³•è°ƒç”¨æµç¨‹å›¾](#æ–¹æ³•è°ƒç”¨æµç¨‹å›¾)
4. [éç†æƒ³å› ç´ åˆ†ç±»](#éç†æƒ³å› ç´ åˆ†ç±»)
5. [æ ¸å¿ƒæ–¹æ³•è¯¦è§£](#æ ¸å¿ƒæ–¹æ³•è¯¦è§£)
6. [æ—¶é’Ÿä¸æŠ–åŠ¨å»ºæ¨¡](#æ—¶é’Ÿä¸æŠ–åŠ¨å»ºæ¨¡)

---

## ç±»ç»§æ‰¿å…³ç³»

```
IdealSARADC (çˆ¶ç±»)
    â”‚
    â”œâ”€ ç»§æ‰¿æ‰€æœ‰åŸºç¡€åŠŸèƒ½
    â”‚   â”œâ”€ __init__() - åŸºç¡€å‚æ•°åˆå§‹åŒ–
    â”‚   â”œâ”€ convert() - ä¸»è½¬æ¢æ¥å£
    â”‚   â”œâ”€ convert_array() - æ‰¹é‡è½¬æ¢
    â”‚   â”œâ”€ digital_to_voltage() - æ•°å­—ç è½¬ç”µå‹
    â”‚   â””â”€ get_info() - è·å–å‚æ•°ä¿¡æ¯
    â”‚
    â””â”€ NonIdealSARADC (å­ç±»)
        â”‚
        â”œâ”€ é‡å†™/æ‰©å±•çš„æ–¹æ³•
        â”‚   â”œâ”€ __init__() - æ·»åŠ éç†æƒ³ä¸æ—¶é’Ÿå‚æ•°
        â”‚   â”œâ”€ _sample_and_hold() - éç†æƒ³é‡‡æ ·ä¿æŒ
        â”‚   â”œâ”€ _synchronous_conversion() - éç†æƒ³è½¬æ¢æµç¨‹ï¼ˆå«æ—¶åºåˆ¤å®šï¼‰
        â”‚   â””â”€ get_info() - æ‰©å±•å‚æ•°ä¿¡æ¯
        â”‚
        â””â”€ æ–°å¢çš„æ–¹æ³•
            â”œâ”€ _nonideal_comparator() - éç†æƒ³æ¯”è¾ƒå™¨ï¼ˆæœ‰é™å¢ç›Š/éšæœºæ€§ï¼‰
            â”œâ”€ _vdac_nonideal() - éç†æƒ³DACï¼ˆINL/DNL/å¢ç›Š/å¤±è°ƒï¼‰
            â”œâ”€ _build_dac_error_table() - æ„å»ºDACè¯¯å·®è¡¨
            â””â”€ _enforce_monotonicity() - å¼ºåˆ¶DACå•è°ƒæ€§
```

---

## åˆå§‹åŒ–æµç¨‹

```
ç”¨æˆ·è°ƒç”¨: NonIdealSARADC(...)
    â”‚
    â”œâ”€ 1. è°ƒç”¨ super().__init__()
    â”‚   â””â”€ åˆå§‹åŒ–åŸºç¡€å‚æ•° (resolution, vref_pos, vref_neg, etc.)
    â”‚
    â”œâ”€ 2. å­˜å‚¨éç†æƒ³å‚æ•°
    â”‚   â”œâ”€ é‡‡æ ·ä¿æŒå‚æ•°ï¼ˆsampling_noise_std, hold_droop_rate, sampling_time_error, ...ï¼‰
    â”‚   â”œâ”€ æ¯”è¾ƒå™¨å‚æ•°ï¼ˆcomparator_offset, comparator_offset_std, comparator_gain, comparator_delayï¼‰
    â”‚   â”œâ”€ DACå‚æ•°ï¼ˆdac_inl_lut, cap_mismatch_sigma, dac_offset, dac_gain_error, enforce_dac_monotonicityï¼‰
    â”‚   â””â”€ é‡åŒ–å‚æ•°ï¼ˆquantization_noise_stdï¼‰
    â”‚
    â”œâ”€ 3. åˆå§‹åŒ–éšæœºæ•°å‘ç”Ÿå™¨
    â”‚   â””â”€ self._rng = np.random.default_rng()
    â”‚
    â”œâ”€ 4. æ—¶é’Ÿ/æ—¶åºå‚æ•°
    â”‚   â”œâ”€ sample_rate_hzï¼ˆé‡‡æ ·é¢‘ç‡ï¼‰
    â”‚   â”œâ”€ sar_bit_period_sï¼ˆæ¯ä½æ¯”è¾ƒé—´éš”ï¼‰
    â”‚   â”œâ”€ aperture_jitter_rms_sï¼ˆå­”å¾„æŠ–åŠ¨RMSï¼‰
    â”‚   â”œâ”€ bit_jitter_rms_sï¼ˆæ¯ä½æ¯”è¾ƒæŠ–åŠ¨RMSï¼‰
    â”‚   â”œâ”€ dac_settle_time_sï¼ˆDACå»ºç«‹æ—¶é—´ï¼‰
    â”‚   â””â”€ comp_regen_time_sï¼ˆæ¯”è¾ƒå™¨å†ç”Ÿæ—¶é—´ï¼‰
    â”‚
    â”œâ”€ 5. æ„å»ºDACè¯¯å·®è¡¨
    â”‚   â””â”€ self._build_dac_error_table()
    â”‚       â”œâ”€ å¦‚æœæä¾› dac_inl_lut â†’ ç›´æ¥è½¬æ¢
    â”‚       â”œâ”€ å¦‚æœæä¾› cap_mismatch_sigma â†’ ç”Ÿæˆè¯¯å·®è¡¨
    â”‚       â””â”€ å¦åˆ™ â†’ è¿”å› None
    â”‚
    â””â”€ 6. å¯é€‰ï¼šå¼ºåˆ¶DACå•è°ƒæ€§
        â””â”€ if enforce_dac_monotonicity: self._enforce_monotonicity()
```

---

## æ–¹æ³•è°ƒç”¨æµç¨‹å›¾

### ä¸»è½¬æ¢æµç¨‹ (convertï¼Œæ”¯æŒæ—¶é’Ÿ/æŠ–åŠ¨)

```
ç”¨æˆ·è°ƒç”¨: adc.convert(vin, t0=None, dVdt=None)
    â”‚
    â”œâ”€ æ­¥éª¤0: ç”Ÿæˆç†æƒ³/å¸¦æŠ–åŠ¨çš„æ—¶é—´æˆ³
    â”‚   â””â”€ _compute_timing(t0)
    â”‚       â”œâ”€ t_sample_s = t0 + Î”t_aperture   (Î”t_aperture ~ N(0, Ïƒ_tj))
    â”‚       â””â”€ t_bit[i] = t_sample + (i+1)Â·Tbit + Î”t_bit[i] (Î”t_bit ~ N(0, Ïƒ_bit))
    â”‚
    â”œâ”€ æ­¥éª¤1: é‡‡æ ·ä¿æŒ
    â”‚   â””â”€ _sample_and_hold(vin)
    â”‚       â”œâ”€ æ·»åŠ é‡‡æ ·å™ªå£° (kT/Cå™ªå£°)ï¼šnoise = N(0, sampling_noise_std)
    â”‚       â”œâ”€ è‹¥æä¾› dVdtï¼šå­”å¾„æŠ–åŠ¨ç­‰æ•ˆæ ¡æ­£ Î”V â‰ˆ dVdt Â· Î”t_aperture
    â”‚       â”œâ”€ é‡‡æ ·æ—¶é—´é™åˆ¶è¯¯å·®ï¼šerror = sampling_time_error Ã— U(0,1)
    â”‚       â””â”€ ä¿æŒè¡°å‡ï¼šdroop = hold_droop_rate Ã— å…¸å‹è½¬æ¢æ—¶é—´
    â”‚
    â”œâ”€ æ­¥éª¤2: é€æ¬¡é€¼è¿‘è½¬æ¢
    â”‚   â””â”€ _synchronous_conversion(sampled_voltage, t_sample, t_bits)
    â”‚       â””â”€ å¾ªç¯: ä»MSBåˆ°LSB
    â”‚           â”œâ”€ ç”Ÿæˆæµ‹è¯•ç : test_code = digital_code | (1 << bit_pos)
    â”‚           â”œâ”€ ç”Ÿæˆæµ‹è¯•ç”µå‹: vdac = _vdac_nonideal(test_code)
    â”‚           â”œâ”€ æ¯”è¾ƒå™¨æ¯”è¾ƒ: comp = _nonideal_comparator(vin, vdac)
    â”‚           â”‚   â”œâ”€ å¤±è°ƒï¼ˆå›ºå®š+éšæœºï¼‰
    â”‚           â”‚   â”œâ”€ æœ‰é™å¢ç›Šï¼ˆsigmoidæ¦‚ç‡ï¼‰
    â”‚           â”‚   â”œâ”€ è‹¥ Î”t(i) = t_bit[i]-t_prev < max(t_dac_settle, t_comp_regen):
    â”‚           â”‚   â”‚     æå‡è¯¯åˆ¤æ¦‚ç‡ï¼ˆæœ€å¤š0.5ï¼‰
    â”‚           â”‚   â””â”€ è®°å½•æ—¶åº/å……åˆ†æ€§ï¼št_bit_s, time_since_prev_s, settle_ok, settle_deficit
    â”‚           â””â”€ æ›´æ–°æ•°å­—ç ï¼ˆè‹¥ comp ä¸º True åˆ™ç½®ä½ï¼‰
    â”‚
    â””â”€ æ­¥éª¤3: å¯é€‰é‡åŒ–å™ªå£°  â†’ digital_code += N(0, quantization_noise_std)
        å¹¶è¿”å›ï¼šdigital_code æˆ– (digital_code, history)
        å…¶ä¸­ history æ¯æ­¥å«ï¼šbit, test_code, vdac, comparator_result, final_code,
                            t_sample_s, t_bit_s, time_since_prev_s, settle_ok, settle_deficit
```

---

## éç†æƒ³å› ç´ åˆ†ç±»

### 1. é‡‡æ ·ä¿æŒéç†æƒ³æ€§

```
_sample_and_hold(vin)
    â”‚
    â”œâ”€ é‡‡æ ·å™ªå£° (kT/Cå™ªå£°)
    â”‚   â”œâ”€ å‚æ•°: sampling_noise_std
    â”‚   â”œâ”€ æ¨¡å‹: N(0, ÏƒÂ²) é«˜æ–¯å™ªå£°
    â”‚   â””â”€ å½±å“: æ¯æ¬¡é‡‡æ ·éƒ½æ·»åŠ éšæœºå™ªå£°
    â”‚
    â”œâ”€ é‡‡æ ·æ—¶é—´é™åˆ¶
    â”‚   â”œâ”€ å‚æ•°: sampling_time_error
    â”‚   â”œâ”€ æ¨¡å‹: ç›¸å¯¹è¯¯å·® Ã— éšæœºå› å­
    â”‚   â””â”€ å½±å“: æ¨¡æ‹Ÿé‡‡æ ·æ—¶é—´ä¸è¶³å¯¼è‡´çš„å»ºç«‹è¯¯å·®
    â”‚
    â”œâ”€ å­”å¾„æŠ–åŠ¨ï¼ˆè‹¥æä¾› dVdtï¼‰
    â”‚   â”œâ”€ å‚æ•°: aperture_jitter_rms_s
    â”‚   â”œâ”€ æ¨¡å‹: Î”t ~ N(0, Ïƒ_tj), Î”V â‰ˆ dVdt Â· Î”t
    â”‚   â””â”€ å½±å“: é‡‡æ ·æ—¶åˆ»ä¸ç¡®å®šæ€§è½¬ä¸ºç”µå‹è¯¯å·®
    â”‚
    â””â”€ ä¿æŒè¯¯å·® (ç”µå‹è¡°å‡)
        â”œâ”€ å‚æ•°: hold_droop_rate
        â”œâ”€ æ¨¡å‹: å›ºå®šè¡°å‡ç‡ Ã— è½¬æ¢æ—¶é—´
        â””â”€ å½±å“: æ¨¡æ‹Ÿç”µè·æ³„æ¼å¯¼è‡´çš„ç”µå‹ä¸‹é™
```

### 2. æ¯”è¾ƒå™¨éç†æƒ³æ€§

```
_nonideal_comparator(vin, vdac)
    â”‚
    â”œâ”€ å¤±è°ƒç”µå‹
    â”‚   â”œâ”€ å›ºå®šå¤±è°ƒ: comparator_offset
    â”‚   â”œâ”€ éšæœºå¤±è°ƒ: comparator_offset_std
    â”‚   â””â”€ æ€»å¤±è°ƒ: offset = fixed + N(0, ÏƒÂ²)
    â”‚
    â”œâ”€ æœ‰é™å¢ç›Šæ•ˆåº”
    â”‚   â”œâ”€ å‚æ•°: comparator_gain
    â”‚   â”œâ”€ æ¨¡å‹: sigmoidå‡½æ•°æ¨¡æ‹Ÿæ¨¡ç³ŠåŒºåŸŸ
    â”‚   â””â”€ å½±å“: å½“è¾“å…¥å·®å¾ˆå°æ—¶ï¼Œæ¯”è¾ƒç»“æœä¸ç¡®å®š
    â”‚
    â”œâ”€ å»¶è¿Ÿ/æ—¶åºå……åˆ†æ€§
    â”‚   â”œâ”€ å‚æ•°: comp_regen_time_s
    â”‚   â”œâ”€ åˆ¤å®š: ä¸Šä¸€ä½è‡³å½“å‰ä½çš„æ—¶é—´æ˜¯å¦ â‰¥ comp_regen_time_s
    â”‚   â””â”€ å½±å“: ä¸è¶³æ—¶æŒ‰æ¯”ä¾‹æå‡è¯¯åˆ¤æ¦‚ç‡
    â”‚
    â””â”€ æ¯”è¾ƒæ—¶åˆ»æŠ–åŠ¨
        â”œâ”€ å‚æ•°: bit_jitter_rms_s
        â””â”€ å½±å“: t_bit[i] å¸¦éšæœºæ‰°åŠ¨ï¼Œå½±å“æ—¶åºå……åˆ†æ€§ä¸éšæœºåˆ¤å†³
```

### 3. DACéç†æƒ³æ€§

```
_vdac_nonideal(digital_code)
    â”‚
    â”œâ”€ ç†æƒ³DACè¾“å‡º: super()._ideal_dac(code)
    â”œâ”€ éçº¿æ€§è¯¯å·® (INL/DNL): _dac_error_volts[code] æˆ–ç”±ç”µå®¹å¤±é…æ¨¡å‹ç”Ÿæˆ
    â”œâ”€ å¢ç›Šè¯¯å·®: gain_error = ideal Ã— dac_gain_error
    â””â”€ å¤±è°ƒè¯¯å·®: offset_error = dac_offset
```

### 4. é‡åŒ–éç†æƒ³æ€§

```
_synchronous_conversion() æœ€å
    â””â”€ è‹¥ quantization_noise_std > 0ï¼šdigital_code += N(0, ÏƒÂ²) [å•ä½LSB]
```

---

## æ—¶é’Ÿä¸æŠ–åŠ¨å»ºæ¨¡

- é‡‡æ ·æ—¶é’Ÿï¼š`sample_rate_hz`ï¼ˆç”¨äºç”Ÿæˆ `t_sample_s`ï¼‰
- SARä½æ—¶é’Ÿï¼š`sar_bit_period_s`ï¼ˆç”Ÿæˆ `t_bit[i]`ï¼‰
- å­”å¾„æŠ–åŠ¨ï¼š`aperture_jitter_rms_s`ï¼ˆé‡‡æ ·æ—¶åˆ» Î”tï¼‰
- ä½æŠ–åŠ¨ï¼š`bit_jitter_rms_s`ï¼ˆæ¯ä½æ¯”è¾ƒæ—¶åˆ» Î”tï¼‰
- å»ºç«‹/å†ç”Ÿæ—¶é—´ï¼š`dac_settle_time_s`ã€`comp_regen_time_s`ï¼ˆç”¨äº `settle_ok/deficit`ï¼‰
- å†å²è®°å½•æ–°å¢ï¼š`t_sample_s`ã€`t_bit_s`ã€`time_since_prev_s`ã€`settle_ok`ã€`settle_deficit`

---

## æ ¸å¿ƒæ–¹æ³•è¯¦è§£

### 1. `_build_dac_error_table()` - æ„å»ºDACè¯¯å·®è¡¨

```
è¾“å…¥å‚æ•°:
    â”œâ”€ dac_inl_lut: INLæŸ¥æ‰¾è¡¨ (å•ä½: LSB)
    â””â”€ cap_mismatch_sigma: ç”µå®¹å¤±é…æ ‡å‡†å·®

å¤„ç†æµç¨‹:
    â”‚
    â”œâ”€ æƒ…å†µ1: æä¾›INLæŸ¥æ‰¾è¡¨
    â”‚   â”œâ”€ éªŒè¯é•¿åº¦ = 2^resolution
    â”‚   â””â”€ è½¬æ¢: error[V] = INL[LSB] Ã— LSB[V]
    â”‚
    â”œâ”€ æƒ…å†µ2: æä¾›ç”µå®¹å¤±é…å‚æ•°
    â”‚   â”œâ”€ ç”Ÿæˆæ¯ä¸€ä½çš„ç”µå®¹å¤±é…
    â”‚   â”‚   â””â”€ C_b = 2^b Ã— C_unit Ã— (1 + Î´_b)
    â”‚   â”‚       â””â”€ Î´_b ~ N(0, ÏƒÂ²)
    â”‚   â”‚
    â”‚   â”œâ”€ å¯¹æ¯ä¸ªç è®¡ç®—éç†æƒ³ç”µå‹
    â”‚   â”‚   â””â”€ V_nonideal = Vref_range Ã— (Î£(bit_i Ã— C_i) / Î£(C_i))
    â”‚   â”‚
    â”‚   â”œâ”€ è®¡ç®—è¯¯å·®
    â”‚   â”‚   â””â”€ error = V_nonideal - V_ideal
    â”‚   â”‚
    â”‚   â””â”€ å›ºå®šç«¯ç‚¹ (å»é™¤æ•´ä½“æ¼‚ç§»)
    â”‚       â”œâ”€ errors[0] = 0
    â”‚       â””â”€ errors[-1] = 0
    â”‚
    â””â”€ æƒ…å†µ3: æ— DACè¯¯å·®
        â””â”€ è¿”å› None
```

### 2. `_enforce_monotonicity()` - å¼ºåˆ¶DACå•è°ƒæ€§

```
è¾“å…¥: error_table (å¯èƒ½åŒ…å«éå•è°ƒè¯¯å·®)

å¤„ç†æµç¨‹:
    â”‚
    â”œâ”€ è®¡ç®—æ¯ä¸ªç çš„ç†æƒ³ç”µå‹
    â”‚   â””â”€ ideal_voltages[code] = _ideal_dac(code)
    â”‚
    â”œâ”€ è®¡ç®—æ¯ä¸ªç çš„å®é™…ç”µå‹
    â”‚   â””â”€ actual_voltages = ideal_voltages + error_table
    â”‚
    â””â”€ ä¿®æ­£éå•è°ƒæ€§
        â””â”€ å¾ªç¯: i = 1 â†’ num_codes-1
            â””â”€ if actual_voltages[i] < actual_voltages[i-1]:
                   â””â”€ è°ƒæ•´è¯¯å·®ï¼Œä½¿å½“å‰ç ç”µå‹ â‰¥ å‰ä¸€ä¸ªç ç”µå‹
```

### 3. `_nonideal_comparator()` - éç†æƒ³æ¯”è¾ƒå™¨

```
è¾“å…¥: vin (è¾“å…¥ç”µå‹), vdac (DACè¾“å‡ºç”µå‹)

å¤„ç†æµç¨‹:
    â”‚
    â”œâ”€ æ­¥éª¤1: è®¡ç®—æ€»å¤±è°ƒ
    â”‚   â”œâ”€ å›ºå®šå¤±è°ƒ: comparator_offset
    â”‚   â”œâ”€ éšæœºå¤±è°ƒ: N(0, comparator_offset_stdÂ²)
    â”‚   â””â”€ total_offset = fixed + random
    â”‚
    â”œâ”€ æ­¥éª¤2: è®¡ç®—æœ‰æ•ˆè¾“å…¥å·®
    â”‚   â””â”€ input_diff = vin - vdac - total_offset
    â”‚
    â”œâ”€ æ­¥éª¤3: æœ‰é™å¢ç›Šæ•ˆåº”åˆ¤æ–­
    â”‚   â””â”€ if gain < âˆ AND |input_diff| < threshold:
    â”‚       â”œâ”€ è®¡ç®—æ¨¡ç³ŠåŒºåŸŸé˜ˆå€¼
    â”‚       â”‚   â””â”€ threshold = Vref_range / gain
    â”‚       â”‚
    â”‚       â”œâ”€ ä½¿ç”¨sigmoidå‡½æ•°è®¡ç®—æ¦‚ç‡
    â”‚       â”‚   â””â”€ prob = 1 / (1 + exp(-input_diff / (threshold/3)))
    â”‚       â”‚
    â”‚       â””â”€ éšæœºå†³å®šæ¯”è¾ƒç»“æœ
    â”‚           â””â”€ return random() < prob
    â”‚
    â””â”€ æ­¥éª¤4: ç†æƒ³æ¯”è¾ƒ (æˆ–å¢ç›Šè¶³å¤Ÿå¤§)
        â””â”€ return input_diff > 0
```

### 4. `_vdac_nonideal()` - éç†æƒ³DAC

```
è¾“å…¥: digital_code (æ•°å­—ç )

å¤„ç†æµç¨‹:
    â”‚
    â”œâ”€ æ­¥éª¤1: è·å–ç†æƒ³DACè¾“å‡º
    â”‚   â””â”€ ideal = super()._ideal_dac(code)
    â”‚       â””â”€ V = Vref_neg + (code / 2^N) Ã— Vref_range
    â”‚
    â”œâ”€ æ­¥éª¤2: æ·»åŠ éçº¿æ€§è¯¯å·®
    â”‚   â””â”€ if _dac_error_volts is not None:
    â”‚       â””â”€ nonlin_error = _dac_error_volts[code]
    â”‚
    â”œâ”€ æ­¥éª¤3: æ·»åŠ å¢ç›Šè¯¯å·®
    â”‚   â””â”€ gain_error = ideal Ã— dac_gain_error
    â”‚
    â”œâ”€ æ­¥éª¤4: æ·»åŠ å¤±è°ƒè¯¯å·®
    â”‚   â””â”€ offset_error = dac_offset
    â”‚
    â””â”€ æ­¥éª¤5: è¿”å›æ€»è¾“å‡º
        â””â”€ return ideal + nonlin_error + gain_error + offset_error
```

---

## æ–¹æ³•è°ƒç”¨é¡ºåºæ€»ç»“

### å®Œæ•´è½¬æ¢æµç¨‹

```
1. ç”¨æˆ·è°ƒç”¨
   â””â”€ adc.convert(vin) æˆ– adc.convert_array(voltages)
       â”‚
       â”œâ”€ 2. é‡‡æ ·ä¿æŒé˜¶æ®µ
       â”‚   â””â”€ _sample_and_hold(vin)
       â”‚       â”œâ”€ æ·»åŠ é‡‡æ ·å™ªå£°
       â”‚       â”œâ”€ æ·»åŠ é‡‡æ ·æ—¶é—´è¯¯å·®
       â”‚       â””â”€ æ·»åŠ ä¿æŒè¡°å‡
       â”‚
       â”œâ”€ 3. é€æ¬¡é€¼è¿‘è½¬æ¢
       â”‚   â””â”€ _synchronous_conversion(sampled_voltage)
       â”‚       â”‚
       â”‚       â””â”€ å¾ªç¯ N æ¬¡ (N = resolution)
       â”‚           â”‚
       â”‚           â”œâ”€ 3.1 ç”Ÿæˆæµ‹è¯•ç 
       â”‚           â”‚
       â”‚           â”œâ”€ 3.2 DACç”Ÿæˆæµ‹è¯•ç”µå‹
       â”‚           â”‚   â””â”€ _vdac_nonideal(test_code)
       â”‚           â”‚       â”œâ”€ super()._ideal_dac() [è°ƒç”¨çˆ¶ç±»]
       â”‚           â”‚       â”œâ”€ æ·»åŠ éçº¿æ€§è¯¯å·®
       â”‚           â”‚       â”œâ”€ æ·»åŠ å¢ç›Šè¯¯å·®
       â”‚           â”‚       â””â”€ æ·»åŠ å¤±è°ƒè¯¯å·®
       â”‚           â”‚
       â”‚           â”œâ”€ 3.3 æ¯”è¾ƒå™¨æ¯”è¾ƒ
       â”‚           â”‚   â””â”€ _nonideal_comparator(vin, vdac)
       â”‚           â”‚       â”œâ”€ è®¡ç®—å¤±è°ƒ
       â”‚           â”‚       â”œâ”€ æœ‰é™å¢ç›Šæ•ˆåº”
       â”‚           â”‚       â””â”€ è¿”å›æ¯”è¾ƒç»“æœ
       â”‚           â”‚
       â”‚           â””â”€ 3.4 æ›´æ–°æ•°å­—ç 
       â”‚
       â”œâ”€ 4. æ·»åŠ é‡åŒ–å™ªå£°
       â”‚   â””â”€ (åœ¨ _synchronous_conversion å†…éƒ¨)
       â”‚
       â””â”€ 5. è¿”å›ç»“æœ
           â””â”€ digital_code (æˆ– digital_code, history)
```

---

## å…³é”®å‚æ•°é€ŸæŸ¥è¡¨

### é‡‡æ ·ä¿æŒå‚æ•°
| å‚æ•° | ç±»å‹ | å•ä½ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|------|--------|------|
| `sampling_noise_std` | float | V | 0.0 | é‡‡æ ·å™ªå£°æ ‡å‡†å·® (kT/Cå™ªå£°) |
| `hold_droop_rate` | float | V/s | 0.0 | ä¿æŒé˜¶æ®µç”µå‹è¡°å‡ç‡ |
| `sampling_time_error` | float | - | 0.0 | é‡‡æ ·æ—¶é—´ä¸è¶³è¯¯å·® (ç›¸å¯¹å€¼) |
| `aperture_jitter_rms_s` | float | s | 0.0 | å­”å¾„æŠ–åŠ¨RMSï¼ˆé‡‡æ ·æ—¶åˆ»æŠ–åŠ¨ï¼‰ |

### æ¯”è¾ƒå™¨å‚æ•°
| å‚æ•° | ç±»å‹ | å•ä½ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|------|--------|------|
| `comparator_offset` | float | V | 0.0 | æ¯”è¾ƒå™¨å›ºå®šå¤±è°ƒ |
| `comparator_offset_std` | float | V | 0.0 | æ¯”è¾ƒå™¨éšæœºå¤±è°ƒæ ‡å‡†å·® |
| `comparator_delay` | float | s | 0.0 | æ¯”è¾ƒå™¨å»¶è¿Ÿ (é€šå¸¸å¿½ç•¥) |
| `comparator_gain` | float | - | âˆ | æ¯”è¾ƒå™¨å¢ç›Š (âˆè¡¨ç¤ºç†æƒ³) |
| `comp_regen_time_s` | float | s | 0.0 | æ¯”è¾ƒå™¨å†ç”Ÿæ—¶é—´ |
| `bit_jitter_rms_s` | float | s | 0.0 | æ¯ä½æ¯”è¾ƒæ—¶åˆ»æŠ–åŠ¨RMS |

### DACå‚æ•°
| å‚æ•° | ç±»å‹ | å•ä½ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|------|--------|------|
| `dac_inl_lut` | np.ndarray | LSB | None | INLæŸ¥æ‰¾è¡¨ (é•¿åº¦=2^N) |
| `cap_mismatch_sigma` | float | - | 0.0 | ç”µå®¹å¤±é…æ ‡å‡†å·® |
| `dac_offset` | float | V | 0.0 | DACå¤±è°ƒ |
| `dac_gain_error` | float | - | 0.0 | DACå¢ç›Šè¯¯å·® (ç›¸å¯¹å€¼) |
| `enforce_dac_monotonicity` | bool | - | False | æ˜¯å¦å¼ºåˆ¶å•è°ƒæ€§ |
| `dac_settle_time_s` | float | s | 0.0 | DACå»ºç«‹æ—¶é—´ |

### æ—¶é’Ÿ/æ—¶åºå‚æ•°
| å‚æ•° | ç±»å‹ | å•ä½ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|------|--------|------|
| `sample_rate_hz` | float | Hz | None | é‡‡æ ·é¢‘ç‡ |
| `sar_bit_period_s` | float | s | None | æ¯ä½æ¯”è¾ƒé—´éš” |

---

## ä½¿ç”¨å»ºè®®

### ç»¼åˆéç†æƒ³æ€§ï¼ˆå«æ—¶é’Ÿ/æŠ–åŠ¨ï¼‰
```python
adc = NonIdealSARADC(
    resolution=8,
    # é‡‡æ ·ä¿æŒ
    sampling_noise_std=150e-6,
    hold_droop_rate=500.0,
    aperture_jitter_rms_s=200e-15,
    # æ¯”è¾ƒå™¨
    comparator_offset=0.6e-3,
    comparator_offset_std=0.2e-3,
    bit_jitter_rms_s=1e-12,
    comp_regen_time_s=2e-9,
    # DAC
    cap_mismatch_sigma=0.0015,
    dac_offset=0.5e-3,
    dac_gain_error=0.005,
    dac_settle_time_s=3e-9,
    # æ—¶é’Ÿ
    sample_rate_hz=1e6,
    sar_bit_period_s=5e-9,
    # é‡åŒ–
    quantization_noise_std=0.05,
)
```

---

## è®°å¿†è¦ç‚¹

1. **ç»§æ‰¿å…³ç³»**: `NonIdealSARADC` ç»§æ‰¿è‡ª `IdealSARADC`ï¼Œé‡å†™å…³é”®æ–¹æ³•
2. **è°ƒç”¨é¡ºåº**: é‡‡æ ·ä¿æŒ â†’ é€æ¬¡é€¼è¿‘ â†’ é‡åŒ–å™ªå£°
3. **éç†æƒ³å› ç´ **: é‡‡æ ·ä¿æŒã€æ¯”è¾ƒå™¨ã€DACã€é‡åŒ– + æ—¶é’Ÿ/æŠ–åŠ¨/æ—¶åº
4. **DACè¯¯å·®è¡¨**: åˆå§‹åŒ–æ—¶æ„å»ºï¼Œæ”¯æŒ INL æŸ¥è¡¨æˆ–ç”µå®¹å¤±é…æ¨¡å‹
5. **æ¯”è¾ƒå™¨æ¨¡å‹**: ä½¿ç”¨ sigmoid æ¨¡æ‹Ÿæœ‰é™å¢ç›Šä¸éšæœºåˆ¤å†³
6. **å•è°ƒæ€§ä¿®æ­£**: å¯é€‰ï¼Œç¡®ä¿ DAC è¾“å‡ºå•è°ƒé€’å¢
7. **æ—¶é’Ÿä¸æŠ–åŠ¨**: é‡‡æ ·å­”å¾„æŠ–åŠ¨ã€æ¯ä½æ¯”è¾ƒæŠ–åŠ¨ï¼›æ£€æŸ¥å»ºç«‹/å†ç”Ÿæ—¶é—´ï¼›å†å²å«æ—¶é—´æˆ³ä¸å……åˆ†æ€§æ ‡æ³¨

---

*æœ€åæ›´æ–°: 2024*
